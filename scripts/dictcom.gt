package main

import (
	. "builtin"
	"giu"
	"os"
	"tk"
)

var dictDirG = `e:\dictcomdata`

func getDictionaryComPronunciationLocal(wordA string, noStrongA bool) string {
	wordT := tk.EncodeStringSimple(wordA)

	pathT := tk.JoinPath(dictDirG, wordT+".txt")

	if tk.IfFileExists(pathT) {
		pronunT := tk.LoadStringFromFile(pathT)

		if tk.IsErrorString(pronunT) {
			return pronunT
		}

		if noStrongA {
			pronunT = tk.RegReplace(pronunT, `<span\s*class="bold">([^<]*?)</span>`, `'${1}`)
		}

		return tk.Trim(pronunT)
	}

	return tk.GenerateErrorStringF("not found for %v", wordT)
}

func getDictionaryComPronunciation(wordA string, noStrong bool) string {
	rs := getDictionaryComPronunciationLocal(wordA, noStrong)

	if !tk.IsErrorString(rs) {
		pl("hit for %v", wordA)
		return rs
	}

	rs = tk.DownloadPageUTF8("https://www.dictionary.com/browse/"+tk.UrlEncode2(wordA), nil, "", 15)
	if tk.IsErrorString(rs) {
		return rs
	}

	pronunT := tk.RegFindFirst(rs, `<div\s*class="pron-spell-container[^>]*>\s*<span\s*class="pron-spell-content[^>]*>(.*?)</span><button`, 1)

	if tk.IsErrorString(pronunT) {
		return pronunT
	}

	pronunT = tk.RegReplace(pronunT, `<span\s*class="italic">([^<]*?)</span>`, `${1}`)

	if noStrong {
		pronunT = tk.RegReplace(pronunT, `<span\s*class="bold">([^<]*?)</span>`, `'${1}`)
	} else {
		pronunT = tk.RegReplace(pronunT, `<span\s*class="bold">([^<]*?)</span>`, `'<strong>${1}</strong>`)
	}

	pronunT = tk.RegReplace(pronunT, `<span\s*class="[^"]*">([^<]*?)</span>`, `${1}`)

	pronunT = tk.RegReplace(pronunT, `\[\s*(\S.*?\S)\s*\]`, `[${1}]`)

	wordT := tk.EncodeStringSimple(wordA)

	pathT := tk.JoinPath(dictDirG, wordT+".txt")

	rs = tk.SaveStringToFile(pronunT, pathT)

	pl("save local for %v, result: %v", wordT, rs)

	return pronunT
}

var text1 string

func onClick1() {
	textT := text1

	textT = tk.RemoveBOM(textT)

	if tk.IsErrorString(textT) {
		pl("failed to get clipboard text")
		return
	}

	listT := tk.SplitLines(textT)

	wordT := ""

	for i, v := range listT {
		if tk.Contains(v, "[") {
			if tk.Contains(v, `][`) {
				pl("already processed for line %v", i)

				continue
			}

			wordT = tk.RegFindFirst(v, `原型：\s*(\S+?)\s+[^\[]*\[`, 1)

			if tk.IsErrorString(wordT) {
				wordT = tk.RegFindFirst(v, `】\s*(\S+?)\s+`, 1)

				if tk.IsErrorString(wordT) {
					continue
				}

				pronunT := getDictionaryComPronunciation(wordT, true)
				pl("found [%v] %v -> %v", i, wordT, pronunT)

				if tk.IsErrorString(pronunT) {
					tk.Pl("skipping...")
					continue
				}

				listT[i] = tk.RegReplace(v, `】(\s*)(\S+?)(\s+)([^\[]*)\[`, `】${1}${2}${3}${4}`+pronunT+`[`)

				continue
			}

			pronunT := getDictionaryComPronunciation(wordT, true)
			pl("found [%v] %v -> %v", i, wordT, pronunT)

			if tk.IsErrorString(pronunT) {
				pl("skipping...")
				continue
			}

			listT[i] = tk.RegReplace(v, `(原型：\s*)(\S+?)(\s+)([^\[]*)\[`, `${1}${2}${3}${4}`+pronunT+`[`)

			// break
		}
	}

	rs := tk.JoinLinesBySeparator(listT, "\r\n")

	text1 = rs

	pl("done")
}

func onClick2() {
	os.Exit(1)
}

func onEditChange() {

}

func loop() {

	// set the layout of GUI
	layoutT := []giu.Widget{
		giu.Label("Enter the text below."),
		giu.InputTextMultiline("InputTextMultiline001", &text1, -1, -30, 0, nil, onEditChange),

		// widgets in line layout is aligned left to right
		giu.Line(giu.Button("Go", onClick1),
			giu.Button("Close", onClick2)),
	}

	giu.SingleWindow("Dictcom", layoutT)
}

func main() {
	setVar("FontRange", "FULL")
	setVar("FontSize", "15")

	mainWindow := giu.NewMasterWindow("Dictcom", 800, 600, 0, giu.LoadFont)
	//giu.MasterWindowFlagsNotResizable

	giu.LoopWindow(mainWindow, loop)

}
